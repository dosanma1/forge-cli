package sync

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// ModuleBazelData contains template data for MODULE.bazel generation.
type ModuleBazelData struct {
	ModuleName    string
	Version       string
	HasGo         bool
	HasJS         bool
	WorkspaceRepo string
}

const moduleBazelTemplate = `# Generated by forge sync - DO NOT EDIT
# To regenerate: forge sync

module(
    name = "{{.ModuleName}}",
    version = "{{.Version}}",
)

{{if .HasGo}}
# Go dependencies
bazel_dep(name = "rules_go", version = "0.50.1")
bazel_dep(name = "gazelle", version = "0.39.1")
{{end}}

{{if or .HasGo .HasJS}}
# Container image dependencies
bazel_dep(name = "rules_oci", version = "2.0.0")
bazel_dep(name = "rules_pkg", version = "1.0.1")
{{end}}

{{if .HasJS}}
# JavaScript/TypeScript dependencies
bazel_dep(name = "rules_nodejs", version = "6.3.2")
bazel_dep(name = "aspect_rules_js", version = "2.8.2")
bazel_dep(name = "aspect_rules_ts", version = "3.7.1")
{{end}}

{{if or .HasGo .HasJS}}
# Container base images
oci = use_extension("@rules_oci//oci:extensions.bzl", "oci")
{{end}}

{{if .HasGo}}
oci.pull(
    name = "distroless_base",
    digest = "sha256:e9d0321de8927f69ce20e39bfc061343cce395996dfc1f0db6540e5145bc63a5",
    image = "gcr.io/distroless/base",
    platforms = [
        "linux/amd64",
        "linux/arm64",
    ],
)
use_repo(oci, "distroless_base")
{{end}}

{{if .HasJS}}
oci.pull(
    name = "distroless_nodejs",
    image = "gcr.io/distroless/nodejs22-debian12",
    tag = "latest",
    platforms = [
        "linux/amd64",
        "linux/arm64/v8",
    ],
)
use_repo(oci, "distroless_nodejs")
{{end}}

{{if .HasJS}}
# Node.js dependencies
node = use_extension("@rules_nodejs//nodejs:extensions.bzl", "node")
node.toolchain(node_version = "22.11.0")

# NPM dependencies
npm = use_extension("@aspect_rules_js//npm:extensions.bzl", "npm", dev_dependency = True)
{{end}}
`

// GenerateModuleBazel creates MODULE.bazel based on detected languages.
func (s *Syncer) GenerateModuleBazel(languages []string) (string, error) {
	// Detect which language rules are needed
	repoName := ""
	if s.config.Workspace.GitHub != nil && s.config.Workspace.GitHub.Org != "" {
		repoName = fmt.Sprintf("github.com/%s/%s", s.config.Workspace.GitHub.Org, s.config.Workspace.Name)
	}

	data := ModuleBazelData{
		ModuleName:    s.config.Workspace.Name,
		Version:       "0.1.0",
		HasGo:         contains(languages, "go"),
		HasJS:         contains(languages, "nestjs") || contains(languages, "angular") || contains(languages, "react"),
		WorkspaceRepo: repoName,
	}

	tmpl, err := template.New("MODULE.bazel").Parse(moduleBazelTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// WriteModuleBazel writes the generated MODULE.bazel to disk.
func (s *Syncer) WriteModuleBazel(content string, report *SyncReport) error {
	modulePath := filepath.Join(s.workspaceRoot, "MODULE.bazel")

	if s.dryRun {
		fmt.Printf("Would write: %s\n", modulePath)
		return nil
	}

	if err := os.WriteFile(modulePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write MODULE.bazel: %w", err)
	}

	report.CreatedFiles = append(report.CreatedFiles, modulePath)
	return nil
}

// syncModuleBazel regenerates MODULE.bazel based on detected languages.
func (s *Syncer) syncModuleBazel(languages []string, report *SyncReport) error {
	fmt.Println("üìù Regenerating MODULE.bazel...")

	content, err := s.GenerateModuleBazel(languages)
	if err != nil {
		return err
	}

	return s.WriteModuleBazel(content, report)
}

// contains checks if a slice contains a string.
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
