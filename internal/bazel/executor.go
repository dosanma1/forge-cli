package bazel
package bazel





















































































































}	return strings.TrimSpace(string(output)), nil	}		return "", err	if err != nil {	output, err := cmd.Output()	cmd := exec.CommandContext(ctx, e.bazelPath, "version")func (e *Executor) Version(ctx context.Context) (string, error) {// Version returns the Bazel version.}	return "", fmt.Errorf("bazel not found in PATH or ~/.forge/bazel/")	}		return forgeBazel, nil	if _, err := os.Stat(forgeBazel); err == nil {	forgeBazel := filepath.Join(forgeHome, ".forge", "bazel", "bin", "bazelisk")	forgeHome := os.Getenv("HOME")	// Check forge-managed installation	}		return path, nil	if path, err := exec.LookPath("bazel"); err == nil {	// Fall back to bazel	}		return path, nil	if path, err := exec.LookPath("bazelisk"); err == nil {	// Try bazelisk first (recommended)func findBazel() (string, error) {// findBazel locates bazelisk or bazel binary.}	return nil	}		return fmt.Errorf("bazel command failed: %w", err)	if err := cmd.Run(); err != nil {	}		cmd.Stderr = os.Stderr		cmd.Stdout = os.Stdout		// Capture output for progress parsing	} else {		cmd.Stderr = os.Stderr		cmd.Stdout = os.Stdout	if e.verbose {	cmd.Dir = e.workspaceRoot	cmd := exec.CommandContext(ctx, e.bazelPath, args...)func (e *Executor) execute(ctx context.Context, args []string) error {// execute runs a Bazel command with proper output handling.}	return lines, nil	lines := strings.Split(strings.TrimSpace(string(output)), "\n")	}		return nil, fmt.Errorf("query failed: %w", err)	if err != nil {	output, err := cmd.Output()	cmd.Dir = e.workspaceRoot	cmd := exec.CommandContext(ctx, e.bazelPath, "query", query)func (e *Executor) Query(ctx context.Context, query string) ([]string, error) {// Query executes a Bazel query.}	return e.execute(ctx, []string{"run", target})func (e *Executor) Run(ctx context.Context, target string) error {// Run executes a Bazel run command.}	return e.execute(ctx, args)	args = append(args, targets...)	args := []string{"test", "--test_output=errors"}func (e *Executor) Test(ctx context.Context, targets []string) error {// Test executes a Bazel test command.}	return e.execute(ctx, args)	args = append(args, targets...)	args := []string{"build"}func (e *Executor) Build(ctx context.Context, targets []string) error {// Build executes a Bazel build command.}	}, nil		verbose:       verbose,		bazelPath:     bazelPath,		workspaceRoot: workspaceRoot,	return &Executor{	}		return nil, fmt.Errorf("bazel not found: %w (run 'forge setup' to install)", err)	if err != nil {	bazelPath, err := findBazel()	// Find bazelisk or bazelfunc NewExecutor(workspaceRoot string, verbose bool) (*Executor, error) {// NewExecutor creates a new Bazel executor.}	verbose       bool	bazelPath     string	workspaceRoot stringtype Executor struct {// Executor handles Bazel command execution.)	"strings"	"path/filepath"	"os/exec"	"os"	"fmt"	"context"import (