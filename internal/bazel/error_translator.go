package bazel
package bazel















































































































}	return cleaned		cleaned = regexp.MustCompile(`bazel-bin/.*`).ReplaceAllString(cleaned, "[build output]")	// Remove Bazel command lines		cleaned := regexp.MustCompile(`//[^:\s]+:[^\s]+`).ReplaceAllString(err, "[target]")	// Remove Bazel target syntaxfunc (t *ErrorTranslator) cleanError(err string) string {// cleanError removes Bazel-specific jargon.}	return strings.Join(relevant, "\n")		}		relevant = append(relevant, "... (run with --verbose for full output)")		relevant = relevant[:5]	if len(relevant) > 5 {		}		}			relevant = append(relevant, strings.TrimSpace(line))		   (!strings.HasPrefix(line, "  ") && strings.TrimSpace(line) != "") {		   strings.Contains(line, "FAILED:") ||		if strings.Contains(line, "ERROR:") || 		// Skip Bazel internal lines	for _, line := range lines {		var relevant []string	lines := strings.Split(err, "\n")func (t *ErrorTranslator) extractErrorDetail(err string) string {// extractErrorDetail extracts the most relevant error details.}	return "Build configuration error. Run 'forge generate' to fix BUILD files."func (t *ErrorTranslator) translateBuildFileError(err string) string {// translateBuildFileError converts BUILD file errors.}	return "Tests failed. Run 'forge test --verbose' for details."	}			matches[1], matches[1])		return fmt.Sprintf("Tests failed in service '%s'\nRun 'forge test %s --verbose' for details", 	if matches := re.FindStringSubmatch(err); len(matches) > 1 {	re := regexp.MustCompile(`//backend/services/([^/]+)`)func (t *ErrorTranslator) translateTestFailure(err string) string {// translateTestFailure converts test failures.}	return fmt.Sprintf("Build failed:\n%s", t.extractErrorDetail(err))	}			matches[1], matches[2], t.extractErrorDetail(err))		return fmt.Sprintf("Build failed in service '%s' (file: %s)\n%s", 	if matches := re.FindStringSubmatch(err); len(matches) > 2 {	re := regexp.MustCompile(`backend/services/([^/]+)/.*?([^/]+\.go)`)	// Extract service name and filefunc (t *ErrorTranslator) translateCompilationError(err string) string {// translateCompilationError converts compilation errors.}	return "Service not found. Run 'forge generate' to update build files."	}		return fmt.Sprintf("Service '%s' not found. Did you forget to run 'forge generate'?", matches[1])	if matches := re.FindStringSubmatch(err); len(matches) > 1 {	re := regexp.MustCompile(`//backend/services/([^/]+)`)	// Extract service name from path like //backend/services/api-serverfunc (t *ErrorTranslator) translateMissingPackage(err string) string {// translateMissingPackage converts missing package errors.}	return t.cleanError(bazelError)	// Default: return cleaned error	}		return t.translateBuildFileError(bazelError)	if strings.Contains(bazelError, "BUILD") {	// Build file error	}		return t.translateTestFailure(bazelError)	if strings.Contains(bazelError, "FAILED") && strings.Contains(bazelError, "test") {	// Test failure	}		return t.translateCompilationError(bazelError)	if strings.Contains(bazelError, "compilation failed") {	// Compilation error	}		return t.translateMissingPackage(bazelError)	if strings.Contains(bazelError, "no such package") {	// Missing dependency error	// Parse common Bazel error patterns and translate to user termsfunc (t *ErrorTranslator) Translate(bazelError string) string {// Translate converts a Bazel error to a user-friendly message.}	return &ErrorTranslator{}func NewErrorTranslator() *ErrorTranslator {// NewErrorTranslator creates a new error translator.type ErrorTranslator struct{}// ErrorTranslator converts Bazel errors to user-friendly messages.)	"strings"	"regexp"	"fmt"import (